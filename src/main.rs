#![allow(clippy::used_underscore_binding)]

use carousel::{CarouselInput, CarouselModel, CarouselOutput};
use relm4::adw::prelude::*;
use relm4::gtk::gdk;
use relm4::{
    adw, gtk, Component, ComponentController, ComponentParts, ComponentSender, Controller, RelmApp,
    SimpleComponent,
};

mod carousel;
mod theme;
mod welcome;

struct AppModel {
    carousel: Controller<CarouselModel>,
    back_button_visible: bool,
}

#[derive(Debug)]
enum AppInput {
    ShowBackButton,
    HideBackButton,
}

#[relm4::component]
impl SimpleComponent for AppModel {
    type Init = ();
    type Input = AppInput;
    type Output = ();
    // AppWidgets is generated by the macro
    type Widgets = AppWidgets;

    view! {
        adw::ApplicationWindow {
            set_default_width: 750,
            set_default_height: 640,

            gtk::Box {
                set_orientation: gtk::Orientation::Vertical,


                adw::HeaderBar {
                    set_css_classes: &["flat"],

                    #[wrap(Some)]
                    set_title_widget = &adw::CarouselIndicatorDots::builder().orientation(gtk::Orientation::Horizontal).build() {
                        set_carousel: Some(carousel),
                    },


                    pack_start = &gtk::Button::with_label("Back") {
                        set_halign: gtk::Align::Center,
                        #[watch]
                        set_visible: model.back_button_visible,

                        connect_clicked[carousel_sender] => move |_| {
                            carousel_sender.send(CarouselInput::PreviousPage);
                        }
                    },
                },


                adw::ToastOverlay {
                    #[wrap(Some)]
                    #[local_ref]
                     set_child = carousel -> adw::Carousel {
                     }
                },

            },

        }
    }

    // Initialize the UI.
    fn init(
        _counter: Self::Init,
        root: &Self::Root,
        sender: ComponentSender<Self>,
    ) -> ComponentParts<Self> {
        let model = AppModel {
            carousel: CarouselModel::builder().launch(()).forward(
                sender.input_sender(),
                |message| match message {
                    CarouselOutput::ShowBackButton => AppInput::ShowBackButton,
                    CarouselOutput::HideBackButton => AppInput::HideBackButton,
                },
            ),
            back_button_visible: false,
        };

        let carousel = model.carousel.widget();
        let carousel_sender = model.carousel.sender().clone();

        let provider = gtk::CssProvider::new();
        provider.load_from_data(
            r#".theme-selector {
                    border-radius: 100px;
                    margin: 8px;
                    border: 1px solid rgba(145, 145, 145, 0.1);
                    padding: 30px;
                }
                .theme-selector radio {
                    -gtk-icon-source: none;
                    border: none;
                    background: none;
                    box-shadow: none;
                    min-width: 12px;
                    min-height: 12px;
                    transform: translate(34px, 20px);
                    padding: 2px;
                    border-radius: 100px;
                }
                .theme-selector radio:checked {
                -gtk-icon-source: -gtk-icontheme("object-select-symbolic");
                background-color: @theme_selected_bg_color;
                color: @theme_selected_fg_color;
                }
                .theme-selector:checked {
                    border-color: @theme_selected_bg_color;
                    border-width: 2px;
                    background-color: @theme_selected_bg_color;
                }
                .theme-selector.light {
                    background-color: #ffffff;
                }
                .theme-selector.dark {
                    background-color: #202020;
                }
                .theme-selector.light:checked {
                    background-color: #eeeeee;
                }
                .theme-selector.dark:checked {
                    background-color: #303030;
                }"#
            .as_bytes(),
        );

        gtk::StyleContext::add_provider_for_display(
            &gdk::Display::default().unwrap(),
            &provider,
            gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
        );

        // Insert the macro code generation here
        let widgets = view_output!();

        ComponentParts { model, widgets }
    }

    fn update(&mut self, message: Self::Input, _sender: ComponentSender<Self>) {
        match message {
            AppInput::ShowBackButton => self.back_button_visible = true,
            AppInput::HideBackButton => self.back_button_visible = false,
        }
    }
}

fn main() {
    pretty_env_logger::init();
    let app = RelmApp::new("com.rollingrhino.rhino-setup");
    app.run::<AppModel>(());
}
